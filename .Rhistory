y <- dt(x, df = 4)
y[x > qt(input$alpha/2, df = 4, lower.tail = FALSE)] <- NA
return(y)
}
funcShaded()
funcShaded(10)
funcShaded <- function(x) {
y <- dt(x, df = 4)
y[x > qt(0.05/2, df = 4, lower.tail = FALSE)] <- NA
return(y)
}
p <- ggplot(data.frame(x = c(qt(0.99999, df = 4, lower.tail = FALSE), qt(0.99999, df = 4, lower.tail = TRUE))), aes(x = x)) +
stat_function(fun = dt, args = list(df = 4)) +
stat_function(fun=funcShaded, geom="area", alpha=0.8) +
theme_minimal() +
ggtitle(paste0("t distribution")) +
theme(plot.title = element_text(face="bold", hjust = 0.5)) +
ylab("Density") +
xlab("x")
p
funcShaded <- function(x) {
y <- dt(x, df = 4)
y[x > 1.7] <- NA
return(y)
}
p <- ggplot(data.frame(x = c(qt(0.99999, df = 4, lower.tail = FALSE), qt(0.99999, df = 4, lower.tail = TRUE))), aes(x = x)) +
stat_function(fun = dt, args = list(df = 4)) +
stat_function(fun=funcShaded, geom="area", alpha=0.8) +
theme_minimal() +
ggtitle(paste0("t distribution")) +
theme(plot.title = element_text(face="bold", hjust = 0.5)) +
ylab("Density") +
xlab("x")
p
library(shiny)
library(dplyr)
library(ggplot2)
library(dplyr)
library(mixdist)
funcShaded <- function(x) {
y <- dt(x, df = 4)
y[x > 1.7] <- NA
return(y)
}
p <- ggplot(data.frame(x = c(qt(0.99999, df = 4, lower.tail = FALSE), qt(0.99999, df = 4, lower.tail = TRUE))), aes(x = x)) +
stat_function(fun = dt, args = list(df = 4)) +
stat_function(fun=funcShaded, geom="area", alpha=0.8) +
theme_minimal() +
ggtitle(paste0("t distribution")) +
theme(plot.title = element_text(face="bold", hjust = 0.5)) +
ylab("Density") +
xlab("x")
p
funcShaded <- function(x) {
y <- dt(x, df = 4)
y[x > 1.7] <- NA
return(y)
}
p <- ggplot(data.frame(x = c(qt(0.99999, df = 4, lower.tail = FALSE), qt(0.99999, df = 4, lower.tail = TRUE))), aes(x = x)) +
stat_function(fun = dt, args = list(df = 4)) +
#stat_function(fun=funcShaded, geom="area", alpha=0.8) +
theme_minimal() +
ggtitle(paste0("t distribution")) +
theme(plot.title = element_text(face="bold", hjust = 0.5)) +
ylab("Density") +
xlab("x")
p
library(shiny)
library(dplyr)
library(ggplot2)
library(dplyr)
library(mixdist)
funcShaded <- function(x) {
y <- dt(x, df = 4)
y[x > 1.7] <- NA
return(y)
}
p <- ggplot(data.frame(x = c(qt(0.99999, df = 4, lower.tail = FALSE), qt(0.99999, df = 4, lower.tail = TRUE))), aes(x = x)) +
# stat_function(fun = dt, args = list(df = 4)) +
stat_function(fun=funcShaded, geom="area", alpha=0.8) +
theme_minimal() +
ggtitle(paste0("t distribution")) +
theme(plot.title = element_text(face="bold", hjust = 0.5)) +
ylab("Density") +
xlab("x")
p
p <- ggplot(data.frame(x = c(qt(0.99999, df = 4, lower.tail = FALSE), qt(0.99999, df = 4, lower.tail = TRUE))), aes(x = x)) +
stat_function(fun = dt, args = list(df = 4)) +
stat_function(fun=funcShaded, geom="area", alpha=0.8) +
# theme_minimal() +
# ggtitle(paste0("t distribution")) +
# theme(plot.title = element_text(face="bold", hjust = 0.5)) +
ylab("Density") +
xlab("x")
p
funcShaded <- function(x) {
y <- dnorm(x, mean = 0.2, sd = 0.1)
y[x < 0.2 | x > (0.2 + 4 * 0.1)] <- NA
return(y)
}
p9 <- p9 + stat_function(fun=funcShaded, geom="area", fill="#84CA72", alpha=0.2)
p9
library(shiny)
library(dplyr)
library(ggplot2)
library(dplyr)
library(mixdist)
funcShaded <- function(x) {
y <- dnorm(x, mean = 0.2, sd = 0.1)
y[x < 0.2 | x > (0.2 + 4 * 0.1)] <- NA
return(y)
}
p9 <- ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
stat_function(fun = dnorm)
p9
p9 <- p9 + stat_function(fun=funcShaded, geom="area", fill="#84CA72", alpha=0.2)
p9
funcShaded <- function(x) {
y <- dnorm(x, mean = 0.2, sd = 0.1)
y[x < 0.2 | x > (0.2 + 4 * 0.1)] <- NA
return(y)
}
p9 <- ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
stat_function(fun = dnorm)
p9
p9 <- ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
stat_function(fun = dt, args = list(df = 8))
p9
dev.off()
p9 <- ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
stat_function(fun = dt, args = list(df = 8))
p9
runApp()
round(qt(0.05/2, df = 4, lower.tail = FALSE), 3)
runApp()
qt(0.05/2, df = 4)
qt(0.05/2, df = 4, lower.tail = TRUE)
qt(0.05/2, df = 4, lower.tail = FALSE)
runApp()
funcShaded <- function(x) {
y <- dt(x, df = test$parameter)
y[x < qt(input$alpha/2, df = test$parameter, lower.tail = FALSE) & x > qt(input$alpha/2, df = test$parameter) ] <- NA
return(y)
}
funcShaded(1:3)
funcShaded <- function(x) {
y <- dt(x, df = 4)
y[x < qt(0.05/2, df = 4, lower.tail = FALSE) & x > qt(0.05/2, df = 4) ] <- NA
return(y)
}
funcShaded(1:3)
runApp()
runApp()
qnorm(0.025, mean = 0.56, sd = 1.067)
runApp()
shiny::runApp()
test <- prop.test(p = 0.3, n = 30)
test <- prop.test(x = 0.3*10, p = 0.3, n = 30)
test
test <- prop.test(x = 0.3*10, p = 0, n = 30)
test <- prop.test(x = 0.3*10, p = 0.00001, n = 30)
test
test <- prop.test(x = 0.3*10, p = 0.00001, n = 30, correct = FALSE)
test
test <- prop.test(x = 30*0.3, n = 30)
test
test <- prop.test(x = 30*0.3, n = 30, p = 0.1)
test
test <- prop.test(x = 30*0.3, n = 30)
test
test <- prop.test(x = 30*0.3, n = 30, correct = FALSE)
test
test <- prop.test(x = 10, n = 30, correct = FALSE)
test
test <- binom.test(x = 10, n = 30, correct = FALSE)
test
test <- binom.test(x = 10, n = 30)
test
test <- prop.test(x = 10, n = 30, correct = FALSE)
test$conf.int
test <- binom.test(x = 10, n = 30)
test$conf.int
test <- prop.test(x = 10, n = 30, correct = FALSE)
test$conf.int
test$method
test <- prop.test(x = 160, n = 95, correct = FALSE)
test$conf.int
test <- prop.test(x = 95, n = 160, correct = FALSE)
test$conf.int
test
test <- binom.test(x = 95, n = 160)
test$conf.int
(95/160) - (1.96 * sqrt((95/160)*(1-(95/160))/160))
(95/160) + (1.96 * sqrt((95/160)*(1-(95/160))/160))
install.packages("proportion")
library(proportion)
ciWD(n = 30, alp = 0.05)
ciWD(n = 30, alp = 0.05)$x
ciWD(n = 30, alp = 0.05)$x[x == 10]
ciWD(n = 30, alp = 0.05)$x[10]
ciWD(n = 30, alp = 0.05)$LWD[11]
ciWD(n = 30, alp = 0.05)$UWD[11]
(10/30) + (1.96 * sqrt((10/30)*(1-(10/30))/30))
qnorm(0.975)
(10/30) + (qnorm(0.975) * sqrt((10/30)*(1-(10/30))/30))
30*0.333
runApp()
30*1/30
runApp()
prop.z.test <- function(x,n,p=NULL,conf.level=0.95,alternative="less") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
if(length(p) > 0) {
q <- 1-p
SE.phat <- sqrt((p*q)/n)
ts.z <- (phat - p)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
} else {
# If all you have is your sample, use phat to find
# SE.phat, and don't run the hypothesis test:
SE.phat <- sqrt((phat*qhat)/n)
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(estimate=phat,ts.z=ts.z,p.val=p.val,cint=cint))
}
prop.z.test(x = 30*0.3, n = 30)
prop.z.test(p = 0.3, n = 30)
prop.z.test <- function(x,n,p=NULL,conf.level=0.95,alternative="less") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
if(length(p) > 0) {
q <- 1-p
SE.phat <- sqrt((p*q)/n)
ts.z <- (phat - p)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
} else {
# If all you have is your sample, use phat to find
# SE.phat, and don't run the hypothesis test:
SE.phat <- sqrt((phat*qhat)/n)
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 30*0.3, n = 30)
prop.z.test(x = 30*0.3, n = 30, p = 0)
prop.z.test(x = 30*0.3, n = 30, p = 0.5)
prop.z.test(x = 10, n = 30, p = 0.5)
prop.z.test <- function(x,n,p=0.5,conf.level=0.95,alternative="less") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
if(length(p) > 0) {
q <- 1-p
SE.phat <- sqrt((p*q)/n)
ts.z <- (phat - p)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
} else {
# If all you have is your sample, use phat to find
# SE.phat, and don't run the hypothesis test:
SE.phat <- sqrt((phat*qhat)/n)
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test <- function(x,n,p=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
if(length(p) > 0) {
q <- 1-p
SE.phat <- sqrt((p*q)/n)
ts.z <- (phat - p)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
} else {
# If all you have is your sample, use phat to find
# SE.phat, and don't run the hypothesis test:
SE.phat <- sqrt((phat*qhat)/n)
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30, p = 0.5)
prop.z.test <- function(x,n,p=NULL,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
if(length(p) > 0) {
q <- 1-p
SE.phat <- sqrt((p*q)/n)
ts.z <- (phat - p)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
} else {
# If all you have is your sample, use phat to find
# SE.phat, and don't run the hypothesis test:
SE.phat <- sqrt((phat*qhat)/n)
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30, p = 0.5)
prop.z.test <- function(x,n,p=NULL,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
if(length(p) > 0) {
q <- 1-p
SE.phat <- sqrt((p*q)/n)
ts.z <- (phat - p)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
} else {
# If all you have is your sample, use phat to find
# SE.phat, and don't run the hypothesis test:
SE.phat <- sqrt((phat*qhat)/n)
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30)
prop.z.test <- function(x,n,p0=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
SE.phat <- sqrt((phat*qhat)/n)
ts.z <- (phat - p0)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30)
str(prop.z.test(x = 10, n = 30))
prop.z.test <- function(x,n,p0=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
SE.phat <- sqrt((phat*qhat)/n)
ts.z <- (phat - p0)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x=x,n=n,estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
str(prop.z.test(x = 10, n = 30))
runApp()
sqrt(0.3*0.7/30)
runApp()
prop.z.test(x = 30*0.3, n = 30)
prop.z.test(x = 30*0.3, n = 30, p0 = 0)
test_confint <- prop.z.test(x = 30*0.3, n = 30, p0 = 0)
test$conf.int
test_confint$conf.int
test_confint$conf.int[1]
test_confint$conf.int[2]
runApp()
test_confint <- prop.z.test(x = 30*0.3, n = 30, p0 = 0)
test_confint
runApp()
prop.test(x = 10, n = 30)
runApp()
prop.z.test <- function(x,n,p0=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
SE.phat <- sqrt((phat*qhat)/n)
ts.z <- (phat - p0)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x=x,n=n,estimate=phat,stderr = SE.phat, statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30)
prop.z.test(x = 0.3*30, n = 30, p0 = 0)
prop.z.test <- function(x,n,p0=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
SE.phat <- sqrt((phat*qhat)/n)
ts.z <- (phat - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x=x,n=n,estimate=phat,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30, p0 = 0)
runApp()
runApp()
qnorm(0.025, lower.tail = FALSE)
qnorm(0.025, lower.tail = TRUE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()

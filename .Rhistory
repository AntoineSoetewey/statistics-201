cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30)
prop.z.test <- function(x,n,p0=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
SE.phat <- sqrt((phat*qhat)/n)
ts.z <- (phat - p0)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30)
str(prop.z.test(x = 10, n = 30))
prop.z.test <- function(x,n,p0=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
SE.phat <- sqrt((phat*qhat)/n)
ts.z <- (phat - p0)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x=x,n=n,estimate=phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
str(prop.z.test(x = 10, n = 30))
runApp()
sqrt(0.3*0.7/30)
runApp()
prop.z.test(x = 30*0.3, n = 30)
prop.z.test(x = 30*0.3, n = 30, p0 = 0)
test_confint <- prop.z.test(x = 30*0.3, n = 30, p0 = 0)
test$conf.int
test_confint$conf.int
test_confint$conf.int[1]
test_confint$conf.int[2]
runApp()
test_confint <- prop.z.test(x = 30*0.3, n = 30, p0 = 0)
test_confint
runApp()
prop.test(x = 10, n = 30)
runApp()
prop.z.test <- function(x,n,p0=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
SE.phat <- sqrt((phat*qhat)/n)
ts.z <- (phat - p0)/SE.phat
p.val <- pnorm(ts.z)
if(alternative=="two.sided") {
p.val <- p.val * 2
}
if(alternative=="greater") {
p.val <- 1 - p.val
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x=x,n=n,estimate=phat,stderr = SE.phat, statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30)
prop.z.test(x = 0.3*30, n = 30, p0 = 0)
prop.z.test <- function(x,n,p0=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat <- x/n
qhat <- 1 - phat
# If you have p0 from the population or H0, use it.
# Otherwise, use phat and qhat to find SE.phat:
SE.phat <- sqrt((phat*qhat)/n)
ts.z <- (phat - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- phat + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x=x,n=n,estimate=phat,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test(x = 10, n = 30, p0 = 0)
runApp()
runApp()
qnorm(0.025, lower.tail = FALSE)
qnorm(0.025, lower.tail = TRUE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
prop.test(x = c(30*0.3, 30*0.2), n = c(30,30), correct = FALSE)
prop.z.test2 <- function(x1,x2,n1,n2,p0=0.5,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat1 <- x1/n1
qhat1 <- 1 - phat1
phat2 <- x2/n2
qhat2 <- 1 - phat2
SE.phat <- sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
ts.z <- (phat1 - phat2 - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- (phat1 - phat2) + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x1=x1,x2=x2,n1=n1,n2=n2,estimate1=phat1,estimate2=phat2,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0)
prop.z.test2 <- function(x1,x2,n1,n2,p0=0,pooled.stderr=TRUE,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat1 <- x1/n1
qhat1 <- 1 - phat1
phat2 <- x2/n2
qhat2 <- 1 - phat2
SE.phat <- if (pooled.stderr == FALSE) {
sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
} else {
pooled.phat <- ((n1*phat1) + (n2$phat2))/(n1+n2)
sqrt((pooled.phat*(1-pooled.phat))*((1/n1)+(1/n2)))
}
ts.z <- (phat1 - phat2 - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- (phat1 - phat2) + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x1=x1,x2=x2,n1=n1,n2=n2,estimate1=phat1,estimate2=phat2,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0, pooled.stderr = TRUE)
prop.z.test2 <- function(x1,x2,n1,n2,p0=0,pooled.stderr=TRUE,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat1 <- x1/n1
qhat1 <- 1 - phat1
phat2 <- x2/n2
qhat2 <- 1 - phat2
SE.phat <- if (pooled.stderr == FALSE) {
sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
} else {
pooled.phat <- ((n1*phat1) + (n2$phat2))/(n1+n2)
sqrt((pooled.phat*(1-pooled.phat))*((1/n1)+(1/n2)))
}
ts.z <- (phat1 - phat2 - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- (phat1 - phat2) + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x1=x1,x2=x2,n1=n1,n2=n2,estimate1=phat1,estimate2=phat2,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0, pooled.stderr = TRUE)
prop.z.test2 <- function(x1,x2,n1,n2,p0=0,pooled.stderr=TRUE,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat1 <- x1/n1
qhat1 <- 1 - phat1
phat2 <- x2/n2
qhat2 <- 1 - phat2
if (pooled.stderr == FALSE) {
SE.phat <- sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
} else {
pooled.phat <- ((n1*phat1) + (n2$phat2))/(n1+n2)
SE.phat <- sqrt((pooled.phat*(1-pooled.phat))*((1/n1)+(1/n2)))
}
ts.z <- (phat1 - phat2 - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- (phat1 - phat2) + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x1=x1,x2=x2,n1=n1,n2=n2,estimate1=phat1,estimate2=phat2,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0, pooled.stderr = TRUE)
prop.z.test2 <- function(x1,x2,n1,n2,p0=0,pooled.stderr=TRUE,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat1 <- x1/n1
qhat1 <- 1 - phat1
phat2 <- x2/n2
qhat2 <- 1 - phat2
SE.phat <- if (pooled.stderr == FALSE) {
sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
} else {
sqrt(((((n1*phat1) + (n2$phat2))/(n1+n2))*(1-(((n1*phat1) + (n2$phat2))/(n1+n2))))*((1/n1)+(1/n2)))
}
ts.z <- (phat1 - phat2 - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- (phat1 - phat2) + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x1=x1,x2=x2,n1=n1,n2=n2,estimate1=phat1,estimate2=phat2,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0, pooled.stderr = TRUE)
prop.z.test2 <- function(x1,x2,n1,n2,p0=0,pooled.stderr=TRUE,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat1 <- x1/n1
qhat1 <- 1 - phat1
phat2 <- x2/n2
qhat2 <- 1 - phat2
if (pooled.stderr == FALSE) {
SE.phat <- sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
} else {
SE.phat <- sqrt(((((n1*phat1) + (n2$phat2))/(n1+n2))*(1-(((n1*phat1) + (n2$phat2))/(n1+n2))))*((1/n1)+(1/n2)))
}
ts.z <- (phat1 - phat2 - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- (phat1 - phat2) + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x1=x1,x2=x2,n1=n1,n2=n2,estimate1=phat1,estimate2=phat2,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0, pooled.stderr = TRUE)
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0)
prop.z.test2 <- function(x1,x2,n1,n2,p0=0,pooled.stderr=TRUE,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat1 <- x1/n1
qhat1 <- 1 - phat1
phat2 <- x2/n2
qhat2 <- 1 - phat2
if (pooled.stderr == FALSE) {
SE.phat <- sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
} else {
SE.phat <- sqrt(((((n1*phat1) + (n2$phat2))/(n1+n2))*(1-(((n1*phat1) + (n2$phat2))/(n1+n2))))*((1/n1)+(1/n2)))
}
ts.z <- (phat1 - phat2 - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- (phat1 - phat2) + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x1=x1,x2=x2,n1=n1,n2=n2,estimate1=phat1,estimate2=phat2,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0)
phat1 <- 0.3
phat2 <- 0.2
n1 <- 30
n2 <- 30
if (pooled.stderr == FALSE) {
SE.phat <- sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
} else {
SE.phat <- sqrt(((((n1*phat1) + (n2$phat2))/(n1+n2))*(1-(((n1*phat1) + (n2$phat2))/(n1+n2))))*((1/n1)+(1/n2)))
}
SE.phat <- sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
phat1 <- 0.3
phat2 <- 0.2
qhat1 <- 1 - phat1
qhat2 <- 1 - phat2
n1 <- 30
n2 <- 30
SE.phat <- sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
SE.phat
SE.phat <- sqrt(((((n1*phat1) + (n2$phat2))/(n1+n2))*(1-(((n1*phat1) + (n2$phat2))/(n1+n2))))*((1/n1)+(1/n2)))
pooled.phat <- ((n1*phat1) + (n2*phat2))/(n1+n2)
pooled.phat
pooled.qhat <- 1-pooled.phat
pooled.qhat
SE.phat <- sqrt(pooled.phat*pooled.qhat*(1/n1 + 1/n2))
SE.phat
prop.z.test2 <- function(x1,x2,n1,n2,p0=0,pooled.stderr=TRUE,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat1 <- x1/n1
qhat1 <- 1 - phat1
phat2 <- x2/n2
qhat2 <- 1 - phat2
pooled.phat <- ((n1*phat1) + (n2*phat2))/(n1+n2)
pooled.qhat <- 1-pooled.phat
if (pooled.stderr == FALSE) {
SE.phat <- sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
} else {
SE.phat <- sqrt(pooled.phat*pooled.qhat*(1/n1 + 1/n2))
}
ts.z <- (phat1 - phat2 - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- (phat1 - phat2) + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x1=x1,x2=x2,n1=n1,n2=n2,estimate1=phat1,estimate2=phat2,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0, pooled.stderr = TRUE)
prop.z.test2(n1=30,n2=30,x1=30*0.3,x2=30*0.2,p0=0, pooled.stderr = FALSE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
prop.z.test2 <- function(x1,x2,n1,n2,p0=0,pooled.stderr=TRUE,conf.level=0.95,alternative="two.sided") {
ts.z <- NULL
cint <- NULL
p.val <- NULL
phat1 <- x1/n1
qhat1 <- 1 - phat1
phat2 <- x2/n2
qhat2 <- 1 - phat2
pooled.phat <- ((n1*phat1) + (n2*phat2))/(n1+n2)
pooled.qhat <- 1-pooled.phat
if (pooled.stderr == FALSE) {
SE.phat <- sqrt((phat1*qhat1)/n1 + (phat2*qhat2)/n2)
} else {
SE.phat <- sqrt(pooled.phat*pooled.qhat*(1/n1 + 1/n2))
}
ts.z <- (phat1 - phat2 - p0)/SE.phat
p.val <- if (alternative == "two.sided") {
2*pnorm(abs(ts.z), lower.tail = FALSE)
} else if (alternative == "less") {
pnorm(ts.z, lower.tail = TRUE)
} else {
pnorm(ts.z, lower.tail = FALSE)
}
cint <- (phat1 - phat2) + c(
-1*((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat),
((qnorm(((1 - conf.level)/2) + conf.level))*SE.phat) )
return(list(x1=x1,x2=x2,n1=n1,n2=n2,estimate1=phat1,estimate2=phat2,null.value=p0,stderr=SE.phat,statistic=ts.z,p.value=p.val,conf.int=cint))
}
prop.z.test2(n1 = 30, n2 = 30, p1 = 0.2, p2 = 0.3)
0.2*30
0.3*30
prop.z.test2(n1 = 30, n2 = 30, x1 = 6, x2 = 9)
runApp()
runApp()
prop.z.test2(n1 = 30, n2 = 30, x1 = 6, x2 = 9, pooled.stderr = FALSE)
prop.z.test2(n1 = 30, n2 = 30, x1 = 6, x2 = 9, pooled.stderr = FALSE, p0 = 3)
runApp()
runApp()
runApp()
prop.z.test2(n1 = 30, n2 = 30, x1 = 6, x2 = 9, pooled.stderr = FALSE)
res <- prop.test(x = c(490, 400), n = c(500, 500))
res
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
sd(c(1,2))
chisq.test(c(1:5))
library(EnvStats)
install.packages("EnvStats")
runApp()
varTest(x = c(1:5), sigma.squared = 0)
varTest(x = c(1:5), sigma.squared = 1)
varTest(x = c(1:5), sigma.squared = 0.1)
runApp()
runApp()
runApp()
test <- varTest(x = c(1:5), sigma.squared = 0.1)
str(test)
runApp()
test <- varTest(x = c(795, 810, 775, 781, 803, 823, 780), sigma.squared = 0.1)
str(test)
test$estimate
runApp()
test$parameters
test$statistic
round(qchisq(0.05/2, df = 6)),3)
round(qchisq(0.05/2, df = 6),3)
runApp()
round(qchisq(0.025, df = 6, lower.tail = TRUE)),3)
runApp()
runApp()
test <- varTest(x = c(795, 810, 775, 781, 803, 823, 780), sigma.squared = 0.1)
test$estimate
runApp()
round(qchisq(0.05/2, df = 40-1, lower.tail = TRUE)),3)
qchisq(0.05/2, df = 40-1, lower.tail = TRUE)
qchisq(1-0.05/2, df = 40-1, lower.tail = TRUE)
qchisq(1-(0.05/2), df = 40-1, lower.tail = TRUE)
qchisq(1-(0.05), df = 40-1, lower.tail = TRUE)
runApp()
if (!require(devtools)) install.packages("devtools")
require(devtools)
install_github("fpechon/rfCountData")
if (!require(devtools)) install.packages("devtools")
require(devtools)
install_github("fpechon/rfCountData")
library(fpechon/rfCountData)
library(rfCountData)
runApp()
runApp()
runApp()
runApp()
qchisq(1-(0.05), df = 40-1, lower.tail = TRUE)
test
runApp()
qchisq(1-0.05/2, df = 6, lower.tail = FALSE)
qchisq(1-0.05/2, df = 6, lower.tail = FALSE)
runApp()
shiny::runApp()
install.packages("EnvStats")
runApp()
runApp()
shiny::runApp()
install.packages("EnvStats")
install.packages("EnvStats")
runApp()
install.packages("EnvStats")
install.packages("EnvStats")
library(EnvStats)
shiny::runApp()
R.version
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
